# 데이터 가져오기 전략 — 의료업체 통합 “예약 추천” 모듈(병원/약국/검진센터)

## 전제(데이터 범위)
- 본 문서의 “데이터”는 **예약 업무 수행에 필요한 운영 데이터**를 의미한다.
  - 예: 업체/지점 목록, 주소/좌표, 연락처, 영업시간, 제공 서비스(진료/검진/수령 등), 안내/정책 텍스트(준비물/변경·취소 규정), 연락 경로(전화/홈페이지/지도 링크)
- **의료 진단/처방, 의료기록(EMR) 데이터는 수집/연동 대상이 아니다.**

---

## 1. 데이터 소스 옵션별 장단점 비교

### 1.1 소스 후보
- A) **제휴(파트너) API**: 병원/약국/검진센터 또는 예약 플랫폼과 직접 연동
- B) **공공/오픈 데이터**: 공공데이터 포털, 지자체/기관 공개 데이터(시설/기관 목록 등)
- C) **장소/지도 플랫폼 API**: 지도 기반 검색(업체명/좌표/카테고리)과 기본 메타데이터
- D) **3rd-party 예약/디렉토리 애그리게이터**: 이미 예약/목록을 제공하는 중간 사업자 API
- E) **웹 스크래핑(공식 FAQ/안내)**: 병원/약국/검진센터의 공개 안내/FAQ 텍스트 수집(출처 URL 포함)

### 1.2 비교 표(실무 관점)
| 옵션 | 가져올 수 있는 데이터 | 장점 | 단점/리스크 | 적합한 상황 |
|---|---|---|---|---|
| A) 제휴 API | 실제 예약 확정/슬롯(일부) | 실시간성 높음 | 제휴/승인/인증 복잡, 일정 리스크 큼 | 실서비스/장기 |
| B) 공공/오픈 데이터 | 기관 목록/주소/전화/운영 정보(일부) | 합법/명확, 커버리지 확보 | 최신성/정합성 편차 | 추천의 “기본 카탈로그” |
| C) 지도/장소 API | 검색/좌표/기본 메타 | 검색 UX 우수 | 약관/쿼터/상업적 이용 제약 | UI 검색 품질 강화 |
| D) 애그리게이터 | 업체 목록/링크(일부) | 커버리지 확보 | 계약/요금/제약 | 시간/예산 확보 시 |
| E) 스크래핑(공식 FAQ/안내) | 준비물/변경·취소 규정/이용 안내 텍스트 | 추천 설명 품질↑(근거 텍스트) | robots/약관/구조 변경 리스크 | **추천 근거 텍스트 확보** |

---

## 2. 권장 데이터 소스 선정 및 근거

### 2.1 권장안(프로젝트 제출/데모 기준): **B + E (+ 선택 C)**
- **Core(필수)**: B) 공공/오픈 데이터로 업체 카탈로그(병원/약국/검진센터) 확보
- **Core(필수)**: E) 공식 FAQ/안내 텍스트를 스크래핑하여 “추천 근거/준비사항/정책”을 보강
- **Optional(가점/완성도)**: C) 지도/장소 API로 검색 UX 강화(약관/쿼터 확인 전제)

### 2.2 근거(실행 가능성 + 책임 경계)
- **일정/리스크**: 4주 팀 프로젝트에서 제휴(A)·상용 애그리게이터(D)는 승인/계약 변수로 실패 확률이 크다.
- **기능 핵심**: 본 모듈의 핵심은 “추천(조건 수집→후보 제시→핸드오프) + 근거 제시”이며, 이는 **공공 데이터 + 안내 텍스트**로 검증 가능하다.
- **통합 관점**: 타 모듈(영양·알러지/활동)과의 결합은 “컨텍스트 전달”이 핵심이므로, 데이터 소스보다 **인터페이스 안정성**이 더 중요하다.

### 2.3 권장 아키텍처(소스 추상화)
- 외부 소스를 직접 UI/대화 로직에서 호출하지 않고, **ProviderCatalog / ProviderDocs / Recommendation** 3개 인터페이스로 분리한다.
  - `ProviderCatalog`: 업체/지점 검색 및 상세 조회(공공/오픈 데이터)
  - `ProviderDocs`: 공식 FAQ/안내 텍스트(스크래핑/다운로드)
  - `Recommendation`: 추천 생성/조건 변경/저장/핸드오프 로그(내부 저장)

---

## 3. 데이터 모델(최소) 예시

### 3.1 Provider(업체) 스키마(예시)
```json
{
  "provider_id": "prov_001",
  "provider_type": "HOSPITAL",
  "name": "A내과",
  "branch_name": "강남점",
  "phone": "02-000-0000",
  "address": "서울 ...",
  "geo": { "lat": 37.0, "lng": 127.0 },
  "services": ["CLINIC"],
  "opening_hours": [
    { "dow": "MON", "open": "09:00", "close": "18:00" }
  ],
  "source": { "type": "SEED", "source_id": "seed:prov_001", "updated_at": "2025-12-31T00:00:00Z" }
}
```

### 3.2 Slot(가용 슬롯) 스키마(예시)
```json
{
  "provider_id": "prov_001",
  "service_type": "CLINIC",
  "start_at": "2026-01-01T09:00:00+09:00",
  "end_at": "2026-01-01T09:30:00+09:00",
  "capacity": 1,
  "remaining": 1,
  "source": { "type": "MOCK_AVAILABILITY", "updated_at": "2025-12-31T00:00:00Z" }
}
```

---

## 4. 엣지 케이스 처리(데이터 없음, 중복 등)

### 4.1 “데이터 없음” 케이스
| 상황 | 예시 | 처리 원칙(UX/로직) |
|---|---|---|
| 업체 검색 결과 0건 | “강남역 근처 검진센터” → 0건 | 검색 조건 완화(반경 확대/키워드 재확인) + 대체 제안(인기 3곳/다른 동네) |
| 슬롯 데이터 없음 | 업체는 있는데 가능 시간 조회가 비어있음 | “가능 시간 확인 불가” 안내 + (1) 사용자가 원하는 시간 수집 후 대체 슬롯 제안 또는 (2) 연락처 안내 |
| 필수 필드 결손 | 전화/주소 누락 | 목록에 노출하되 “정보 부족” 표기, 예약 확정 단계에서는 연락수단 확보 필수 |

### 4.2 “중복” 케이스(업체/지점/슬롯)
| 상황 | 원인 | 처리 원칙 |
|---|---|---|
| 동일 업체가 여러 소스에서 중복 | B(공공) + C(지도) 병합 | **정규화 키**(전화/주소+좌표/이름 유사도)로 병합, `source`를 배열로 보관 |
| 지점명 상이 | “강남점” vs “강남역점” | 사용자 노출은 하나로 통합하되, 내부에 alias 저장 |
| 동일 슬롯 중복 | 여러 호출/캐시 문제 | `(provider_id, service_type, start_at)`를 유니크 키로 dedup |

### 4.3 “정합성/최신성” 케이스
| 상황 | 예시 | 처리 원칙 |
|---|---|---|
| 영업시간과 슬롯 불일치 | 일요일 휴무인데 슬롯 존재 | 슬롯을 우선으로 하되, 검증 규칙으로 비정상 슬롯 제외 + 소스 업데이트 필요 표시 |
| 예약 확정 직전 슬롯 소진 | 사용자가 선택한 18:00 마감 | `EVT_SLOT_UNAVAILABLE`로 처리 → 대안 슬롯 3개 제시 → 재컨펌 |
| 타임존/날짜 경계 | 자정 근처 예약 | 모든 시간은 ISO-8601 + TZ 포함 저장, 사용자 표기는 로컬 TZ |

### 4.4 “예약 중복 생성” 케이스(사용자 관점)
| 상황 | 예시 | 처리 원칙 |
|---|---|---|
| 사용자가 같은 예약을 반복 생성 | 네트워크 지연/재시도 | `idempotency_key` 적용(사용자+provider+slot+phone 해시)하여 중복 생성 방지 |

---

## 5. 구현 예시(코드 블록)

### 5.1 소스 추상화 인터페이스(의사코드)
```ts
type ProviderType = "HOSPITAL" | "PHARMACY" | "CHECKUP_CENTER";
type ServiceType = "CLINIC" | "CHECKUP" | "PICKUP";

interface ProviderCatalog {
  searchProviders(params: {
    providerType: ProviderType;
    query?: string;      // 업체명/키워드
    region?: string;     // 지역명
    near?: { lat: number; lng: number; radiusM: number };
  }): Promise<Array<{ providerId: string; name: string; address?: string; phone?: string }>>;
}

interface ProviderDocs {
  listDocs(params: {
    providerId: string;
    docType: "FAQ" | "NOTICE" | "POLICY";
  }): Promise<Array<{ title?: string; text: string; sourceUrl?: string; fetchedAt: string }>>;
}

interface Recommendation {
  recommend(input: {
    providerType: ProviderType;
    region?: string;
    near?: { lat: number; lng: number; radiusM: number };
    serviceType?: ServiceType;
    timeWindow?: "MORNING" | "AFTERNOON" | "EVENING";
    notes?: string; // 사용자 요청(짧게)
  }): Promise<{
    candidates: Array<{
      providerId: string;
      name: string;
      phone?: string;
      address?: string;
      sourceSummary?: string; // 추천 근거 요약(FAQ/정책 등)
      links?: { homepage?: string; map?: string };
    }>;
  }>;
}
```

### 5.2 중복 방지(Idempotency) 키 생성(예시)
```ts
import crypto from "crypto";

export function buildIdempotencyKey(input: {
  userId: string;
  providerId: string;
  providerType: string;
  region?: string;
  timeWindow?: string;
}): string {
  const raw = `${input.userId}|${input.providerId}|${input.providerType}|${input.region ?? ""}|${input.timeWindow ?? ""}`;
  return crypto.createHash("sha256").update(raw).digest("hex").slice(0, 32);
}
```

### 5.3 업체 중복 병합(간단 규칙 예시)
```python
from difflib import SequenceMatcher

def similar(a: str, b: str) -> float:
    return SequenceMatcher(None, a.lower(), b.lower()).ratio()

def merge_candidates(a, b):
    # 우선순위: 전화 > 주소 > 이름 유사도
    if a.get("phone") and b.get("phone") and a["phone"] == b["phone"]:
        return True
    if a.get("address") and b.get("address") and a["address"] == b["address"]:
        return True
    if a.get("name") and b.get("name") and similar(a["name"], b["name"]) >= 0.9:
        return True
    return False
```

---

## 6. 결론(요약)
- **권장 소스 조합(제출/데모 기준)**: 내부 Seed+모킹(E)을 기본으로, 공공 데이터(B) 또는 지도 API(C)를 선택적으로 결합한다.
- **핵심은 소스 교체 가능 구조**: `ProviderCatalog / Availability / Booking`으로 추상화하여, 향후 제휴 API(A)로 단계적 전환이 가능하도록 한다.
- **엣지 케이스는 상태머신과 결합**: 슬롯 불가/연동 실패/중복 생성 등은 이벤트(`EVT_SLOT_UNAVAILABLE`, `EVT_PROVIDER_API_FAIL`)로 처리하여 복구 경로를 제공한다.


